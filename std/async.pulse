// Pulse Standard Library - Async Module
// Week 9 - Pure Pulse Implementation
// Asynchronous programming utilities integrating Week 8 runtime

// Import Week 8 async runtime primitives
import { Channel, select, sleep as runtimeSleep, parallel as runtimeParallel, race as runtimeRace, timeout as runtimeTimeout, retry as runtimeRetry, defer as runtimeDefer, batch as runtimeBatch } from 'lib/runtime/async/index'

async fn sleep(ms) {
  await runtimeSleep(ms)
}

async fn parallel(tasks, options) {
  const opts = options || {}
  return await runtimeParallel(tasks, opts)
}

async fn race(tasks) {
  return await runtimeRace(tasks)
}

async fn timeout(task, ms) {
  return await runtimeTimeout(task, ms)
}

async fn retry(task, options) {
  const opts = options || {}
  return await runtimeRetry(task, opts)
}

fn defer(cleanup) {
  runtimeDefer(cleanup)
}

fn channel(bufferSize) {
  const size = bufferSize || 0
  return new Channel(size)
}

async fn selectCases(cases) {
  return await select(cases)
}

async fn batch(items, processor, options) {
  const opts = options || {}
  return await runtimeBatch(items, processor, opts)
}

fn debounce(fn_input, delay) {
  let timeoutId = null
  let lastArgs = []

  const debouncedFn = fn(arg1, arg2, arg3) {
    lastArgs = [arg1, arg2, arg3]

    if (timeoutId) {
      clearTimeout(timeoutId)
    }

    timeoutId = setTimeout(fn() {
      if (lastArgs.length == 1) {
        fn_input(lastArgs[0])
      } else if (lastArgs.length == 2) {
        fn_input(lastArgs[0], lastArgs[1])
      } else if (lastArgs.length == 3) {
        fn_input(lastArgs[0], lastArgs[1], lastArgs[2])
      } else {
        fn_input()
      }
      timeoutId = null
    }, delay)
  }

  return debouncedFn
}

fn throttle(fn_input, interval) {
  let lastCall = 0
  let throttling = false

  const throttledFn = fn(arg1, arg2, arg3) {
    const now = Date.now()

    if (throttling) {
      return
    }

    if (now - lastCall >= interval) {
      if (arg3 != null) {
        fn_input(arg1, arg2, arg3)
      } else if (arg2 != null) {
        fn_input(arg1, arg2)
      } else if (arg1 != null) {
        fn_input(arg1)
      } else {
        fn_input()
      }
      lastCall = now
    } else {
      throttling = true
      const remaining = interval - (now - lastCall)

      setTimeout(fn() {
        if (arg3 != null) {
          fn_input(arg1, arg2, arg3)
        } else if (arg2 != null) {
          fn_input(arg1, arg2)
        } else if (arg1 != null) {
          fn_input(arg1)
        } else {
          fn_input()
        }
        lastCall = Date.now()
        throttling = false
      }, remaining)
    }
  }

  return throttledFn
}

fn delay(ms, value) {
  return new Promise(fn(resolve) {
    setTimeout(fn() {
      if (value != null && value != undefined) {
        resolve(value)
      } else {
        resolve(null)
      }
    }, ms)
  })
}

async fn waitUntil(condition, options) {
  const opts = options || {}
  const timeoutMs = opts.timeout || 5000
  const intervalMs = opts.interval || 100

  const startTime = Date.now()

  while (true) {
    if (condition()) {
      return true
    }

    if (Date.now() - startTime > timeoutMs) {
      throw 'waitUntil timeout exceeded'
    }

    await sleep(intervalMs)
  }
}

async fn sequence(tasks) {
  const results = []

  for (let i = 0; i < tasks.length; i = i + 1) {
    const result = await tasks[i]()
    results.push(result)
  }

  return results
}

fn promisify(fn_input) {
  return fn(arg1, arg2, arg3) {
    return new Promise(fn(resolve, reject) {
      const callback = fn(err, result) {
        if (err) {
          reject(err)
        } else {
          resolve(result)
        }
      }

      if (arg3 != null) {
        fn_input(arg1, arg2, arg3, callback)
      } else if (arg2 != null) {
        fn_input(arg1, arg2, callback)
      } else if (arg1 != null) {
        fn_input(arg1, callback)
      } else {
        fn_input(callback)
      }
    })
  }
}

// Export all functions
export default {
  sleep: sleep,
  parallel: parallel,
  race: race,
  timeout: timeout,
  retry: retry,
  defer: defer,
  channel: channel,
  select: selectCases,
  batch: batch,
  debounce: debounce,
  throttle: throttle,
  delay: delay,
  waitUntil: waitUntil,
  sequence: sequence,
  promisify: promisify
}
